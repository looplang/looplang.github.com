<!DOCTYPE HTML>
<html>
<head>
  <title>loop documentation</title>

  <link rel="stylesheet" href="../main.css">
  <script type="text/javascript" src="../js/jquery-1.7.1.min.js"></script>
  <script type="text/javascript" src="../js/main.js"></script>
  <script type="text/javascript">
    function toIndexName(title) {
      return title.replace(/[ ]+/, '')
          .replace(/[&:\-!?]+/, '')
          .toLowerCase();
    }

    $(function() {
      // Construct nav index.
      var topItems = $('#main > h2');
      var outline = $('#outline-container > .outline');
      outline.html('');
      topItems.each(function() {
        var subItems = ['<ul>'];
        $(this).nextAll('*').each(function() {
          // Read all nodes until we get to the next h2 tag.
          var tag = $(this)[0].nodeName.toLowerCase();
          if (tag == 'h2')
            return false;
          else if (tag != 'h3')
            return true;

          var name = toIndexName($(this).text());
          // Drop an anchor near this section.
          $(this).prepend('<a name="' + name + '"/>');

          // Link to the relevant anchor
          subItems.push('<li><a href="#' + name +'">');
          subItems.push($(this).text());
          subItems.push('</a></li>');
        });
        subItems.push('</ul>');

        var name = toIndexName($(this).text());

        // Drop anchor near this title.
        $(this).prepend('<a name="' + name + '"/>');
        outline.append('<li><a href="#' + name + '">' + $(this).text() + '</a>' + subItems.join('') + '</li>')
      });

      $('#outline-container > .outline > li > a').live('click', function() {
        $(this).parent().find('ul').slideToggle();
      }).first()
        .click();
    });
  </script>
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-24538005-4']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</head>
<body>
<a name="#top"></a>
<header>
  <h1>loop</h1>
  <nav>
    <a href="/about">About</a>
    <a href="#gettingstarted">Get Loop</a>
    <a>Documentation</a>
    <a href="/faq">FAQ</a>
    <a href="https://groups.google.com/group/looplang">Mailing List</a>
  </nav>
</header>
<section id="main">

  <div id="outline-container">
    <h3><a href="#top">Index</a></h3>
    <ul class="outline"></ul>
  </div>

  <h2>Introduction</h2>

  <h3>Philosophy</h3>

  <p>
    As a programming language, Loop prizes a readable, compact and elegant syntax.
    Many design choices are made in favor of clarity over convenience.
  </p>
  <p>
    The influences of
    Haskell, Scheme, Ruby and Erlang are all present and Loop attempts to use familiar constructs wherever possible.
  </p>

  <p>
    Loop also emphasizes <i>performance over purity</i> or theoretical considerations.
    This means that practical design choices generally rule the day. One of the key motivations behind running on the
    JVM is the vast array of existing libraries that are instantly available; and of course the
    outstanding performance of a VM techonology developed over decades, that runs easily on multiple platforms.
  </p>
  <p>Programs (or scripts) are compiled
    on-the-fly to optimized JVM bytecode and therefore suffer no performance penalty to interpretation;
    all while maintaining the quick, edit-and-run responsiveness of interpreted code.
  </p>

  <p>
    The overall philosophy is to bring together the best features of functional programming
    with the practical and ease-of-use lessons in modern imperative and OO languages, but to do so
    in a comprehensive and consistent manner. It has also
    been designed with concurrency in mind right from the start.
  </p>
  <p>
    Sometimes new languages feel like an endless agglomeration of features,
    a niche satisfier, or just plain bolted-on, even if they have excellent ideas.
    Loop's approach is to balance such new ideas with performance considerations
    and present them in a consistent, pragmatic and elegant form.
  </p>

  <p>
    Being functional in nature, the language doesn't have any of the baggage of the host platform (Java), but borrows
    <a href="#callingfunctions">semantically</a> and interoperates where appropriate.
  </p>

  <p>
    Loop is currently a work-in-progress, I invite you to come and play.
  </p>

  <h3>Getting started</h3>
  <p>
    you will need java 1.6 or higher already installed. check if you have it by running:
  </p>
  <div class="code">
<pre>$ ~java -version~
java version "1.6.0_31"
Java(TM) SE Runtime Environment
Java HotSpot(TM) 64-Bit Server VM</pre>
  </div>

  <p>
    download and unzip the <a href="#">loop distribution</a>. from the directory you unzipped
    it into, run:
  </p>
  <div class="code">
<pre>$ ~./loop~</pre>
  </div>
  <p>
    this will bring up the loop shell, from where you can execute simple loop expressions
    and functions
  </p>
  <div class="code">
<pre>loOp (http://looplang.org)
     by Dhanji R. Prasanna

>> ~1 + 2 + 4~
7
>> ~alert('hi there') ~
>> :help
</pre>
  </div>

  <p>
    If you want to run loop from other directories, add loop to the <code>PATH</code>.
    If using the bash shell:
  </p>

  <div class="code">
<pre>$ export PATH=$PATH:/path/to/loop
$ loop
</pre>
  </div>
  <p><i>Note: make sure you replace <code>/path/to</code> with the actual path =)</i></p>

  <p>
    You can make this permanent by adding the aforementioned <code>export</code> line to
    <code>.bash_profile</code> located in your home directory (if using bash).
  </p>

  <h3>My first loop</h3>
  <p>
    like all other decent things, loop programs are stored in files. you can recognize
    a loop program file by its extension <i>.loop</i>.
    they can be executed either from the shell (using :run) or directly from the command line:
  </p>
  <div class="code">
<pre>$ ~./loop myfirst.loop~
hello there
</pre>
  </div>

  <p>
    this snippet above looks for a program file called <i>myfirst.loop</i> and executes it.
    you can create and save this file in any text editor, it contains nothing more than the following:
  </p>
  <div class="code">
<pre>print('hello there')</pre>
  </div>
  <p>
    give this a try now. you can print other things too:
  </p>

  <div class="code">
    <pre>print(1 + 2)
print(5 * 50 / 44)
print(new java.util.Date())</pre>
  </div>
  <p>
    these are called 'free expressions' and they may appear anywhere inside a loop function or
    program. specifically, the function print is being called with different values.

    as you will learn soon, everything in loop is designated in terms of functions
    and values.
  </p>

  <p>
    You should be able to run all of the example code in this documentation via this method (loop
    program files) or via the loop shell itself. I recommend starting with the shell and moving
    to program files when working with more complex examples (particularly when declaring your
    own functions, etc.).
  </p>


  <h3>Evaluation</h3>
  <p>
    so far you have seen how small computations and function calls work in loop. these are known
    as <i>expressions</i>, and form the basic building blocks of all programs.
  </p>
  <div class="code">
<pre>$ ~./loop myfirst.loop~
hello there
</pre>
  </div>

  <p>
    while free expressions in a file are useful for writing quick scripts, if you write a larger
    application (consisting of many .loop files) you will want to define a clear entry point for
    your app. Loop uses the C convention of using a function called <code>main</code>, which is
    called by the runtime if present:
  </p>
  <div class="code">
<pre>main ->
  print('hello there')</pre>
  </div>
  <p>
    give this a try now. you should see the same result. this is the first function we've seen. all
    functions are declared with a name followed by a <code>-></code> arrow. any expressions that
    appear below, belong to the function and will execute when the function is called.
    <code>main</code> can optionally take arguments:
  </p>

  <div class="code">
<pre>main(args) ->
  print(args)</pre>
  </div>
  <p>
    which are passed in via the command line:
  </p>
  <div class="code">
<pre>$ ~./loop echo.loop ahoyhoy~
[ahoyhoy]
</pre>
  </div>
  <p>
    note that this prints a list of arguments, denoted by the brackets - <code>[]</code>. we'll
    see more about lists and functions in the following sections.
  </p>

  <h3>Program structure</h3>
  <p>
    loop files are organized into a formal structure which is enforced by the program parser. it
    is fairly straightforward:
  </p>
  <div class="code">
<pre>
module declaration

import declarations

functions & type definitions

free expressions
</pre>
  </div>
  <p>
    here's an example of a loop program
  </p>

  <div class="code">
<pre>
module mymodule

require other.mod
require yet.another

class Pair ->
  left: 0
  right: 0

main ->
  new Pair(1, 2)   # comments may appear anywhere


# free expressions must appear last
print('mymodule is go!')
</pre>
  </div>

  <p>
    a module declaration appears at the top (usually this is the name of the loop file without the
    .loop extension), followed by <code>require</code> statements that denote imports of other
    modules or java types.
    loop type and function definitions come next and may be mixed,
    but free expressions are always last.
  </p>
  <p>
    note: free expressions in a module are evaluated any time a module is imported and always
    run before <code>main</code>, which, only executes if you specifically run that file. if
    you are familiar with static initializers in java, that's what free expressions are. you are
    encouraged to use main when writing anything more than trivial programs.
  </p>
  <h2>Data structures</h2>
  <p>
    in addition to any available java data structures and types, there are a few built-in types
    in loop.
  </p>

  <h3>Strings</h3>
  <p>
    strings in loop are java strings (unicode, utf-16 <code>java.lang.String</code> objects).
    however there are many special loop-specific extensions for working with them. A normal string
    as we've seen before is enclosed in single quotes:
  </p>
  <div class="code">
<pre>print('this is a string of characters')</pre>
  </div>

  <p>
    double quoted strings are also equivalent, but they may contain expressions that are expanded
    at runtime. for example:
  </p>
  <div class="code">
    <pre>greet(name) ->
  print("hello, @{name}")

greet('Dhanji')</pre>
  </div>

  <p>
    running this program prints <code>hello, Dhanji</code> to the console. any loop expression
    can be embedded inside the <i>orb</i> tags - <code>@{}</code>.
  </p>
  <div class="code">
    <pre>"26 * 34 is @{26 * 34}"

=> "26 * 34 is 884"</pre>
  </div>
  <p>
    if you want to print the orb tags literally, fall back to single quoted strings
  </p>
  <div class="code">
    <pre>'this is inside an @{orb tag}'

=> "this is inside an @{orb tag}"</pre>
  </div>

  <h3>Numbers</h3>
  <p>
    loop has built-in support for most common numeric types. the following java types are
    supported natively:
  </p>
  <div>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet arrow">Integer (32-bit)</li>
      <li><img src="../images/arrow_right.png" alt="bullet arrow">Long (64-bit)</li>
      <li><img src="../images/arrow_right.png" alt="bullet arrow">Double (64-bit)</li>
      <li><img src="../images/arrow_right.png" alt="bullet arrow">BigInteger (arbitrary)</li>
      <li><img src="../images/arrow_right.png" alt="bullet arrow">BigDecimal (arbitrary)</li>
    </ul>
  </div>
  <p>
    loop has no support for floats, shorts or bytes, however these may be manipulated using java
    primitive wrapper types if needed. by default, any integer appearing in a loop program is
    treated as a 32-bit <code>Integer</code>
  </p>
  <div class="code">
    <pre>print(23.getClass())

=> java.lang.Integer</pre>
  </div>
  <p>
    longs, like in java, are specified by suffixing 'L' to a number. note that unlike java this
    must be an uppercase L.
  </p>
  <div class="code">
    <pre>print(23L.getClass())

=> java.lang.Long</pre>
  </div>
  <p>
    a special syntax is also available for arbitrary precision numbers (numbers too large or too
    precise to fit into 64 bits)
  </p>
  <div class="code">
    <pre>print(@23129038102938102938102938)
print(@2.3129038102938102938102938)

=> 23129038102938102938102938
=> 2.3129038102938102938102938</pre>
  </div>
  <p>
    you can add, subtract, multiply, divide, modulus or compare any two values if they are of the
    same numeric type:
  </p>
  <div class="code">
    <pre>3 + 4
=> 7

46L / 2L
=> 23

@2.0 > @1.9999999999999999
=> true</pre>
  </div>
  <p>
    however, unlike java loop forbids mixing numeric types in expressions. you must convert
    all values to the same, compatible type before computing with them.
  </p>
  <div class="code">
    <pre>\3L + 3\

=> \#error\
</pre>
  </div>

  <p>
    this is done to prevent
    surprising behavior and loss of information when converting between types of different
    precision.
    you can convert any number to the largest precision type easily
  </p>
  <div class="code">
    <pre>@3 + 4.embiggen()
=> 7

@3.0 + 4.0.embiggen()
=> 7.0</pre>
  </div>

  <h3>Operators</h3>
  <p>
    operators in loop are symbols that combine two values to produce a resultant value, for example
    the <code>+</code> (plus) operator adds two numbers and produces their sum. operators need not
    necessarily produce the same type of value as the values they combine. for instance, the
    <code>&gt;</code> (greater-than) operator takes two numbers and returns <code>true</code> if the
    first is greater than the second.
  </p>
  <p>
    the following operators are provided with loop
  </p>
  <div class="code">
    <pre>+, -, /, *, %, >, <, >=, <=, ==, not, and, or</pre>
  </div>
  <p>
    some of these operators work on multiple data types. for instance, the + operator can be used
    to <i>concatenate</i> strings together
  </p>
  <div class="code">
    <pre>'1' + '2'

=> '12'</pre>
  </div>
  <p>
    in fact, as long as the string appears on the left, any object may be concatenated with it
  </p>
  <div class="code">
    <pre>'1' + @2

=> '12'</pre></div>
  <p>
    note that no loop operator ever mutates its operands. it simply reads and
    combines them to produce a third, resultant value. (the assign operator is an exception,
    but we'll deal with that later).
  </p>

  <h3>Lists</h3>

  <p>
    lists are an essential component of programming in loop, as as such they are supported
    natively in syntax. all loop lists are perfectly compatible with <code>java.util.List</code>
    and like <code>String</code>, come with some nifty, loop-specific extensions.
  </p>
  <p>
    lists may contain any (or many) type of object. here is a simple list of integers
  </p>
  <div class="code">
    <pre>[1, 2, 3, 4, 5]</pre></div>
  <p>
    lists are zero-based and can be indexed using familiar brackets syntax - <code>[]</code>
  </p>
  <div class="code">
    <pre>third(ls) ->
  ~ls[2]~

third([1, 2, 3])

=> 3</pre></div>
  <p>
    you can also use a similar syntax to slice portions of lists
  </p>
  <div class="code">
    <pre>pick(ls) ->
  ~ls[0..2]~

pick([1, 2, 3, 4, 5, 6, 7])

=> [1, 2, 3]</pre></div>
  <p>
    leaving out a lower or upper bound slices the list from or to the given index
  </p>
  <div class="code">
    <pre>pick(ls) ->
  ~ls[2..] + ls[..1]~

pick([1, 2, 3, 4])

=> [3, 4, 2, 1]</pre></div>
  <p>
    note that i used the <code>+</code> operator here to add the two sub-lists together. it is
    also sometimes useful to generate lists without typing out each entry. you can use the list
    <code>range</code> syntax to accomplish this:
  </p>
  <div class="code">
    <pre>pick(ls) ->
  ls[0..2]

pick(~[1..7]~)    # generate a list of 1-7

=> [1, 2, 3]</pre></div>
  <p>
    the range syntax is very similar to the slice syntax except that slices must on some existing
    list (in the above cases, a list variable, <code>ls</code>). so keep that in mind when reading
    loop code
  </p>

  <h3>Sets</h3>

  <p>
    similarly, loop provides a natural syntax for working with sets. a set is similar
    to a list except that it is a collection of unique items and that they are present in no
    particular order
  </p>
  <div class="code">
    <pre>~{1, 1, 2, 2, 3, 3}~

=> {1, 2, 3}</pre></div>
  <p>
    loop sets are fully compatible with <code>java.util.Set</code> classes.
  </p>

  <h3>Maps</h3>
  <p>
    maps are an extremely useful data structure. sometimes called <i>hashtables</i> or
    just <i>hashes</i>, a map is basically an collection of key/value pairs.
    they are supported natively by loop and
    created using a familar json-like syntax:
  </p>
  <div class="code">
    <pre>{ 'name' : 'Tyrion',
  'house' : 'Lannister' }

=> { name=Tyrion, house=Lannister }</pre></div>
  <p>
    maps may contain any type or many types as either keys or values
  </p>
  <div class="code">
    <pre>{ 1 : 'one',
 @2 : 'two' }

=> { 1=one, 2=two }</pre></div>
  <p>
    read values out of maps using simple dot syntax (like in json)
  </p>
  <div class="code">
    <pre>{ 'name' : 'Tyrion',
  'house' : 'Lannister' }.~house~ + ' pays his debts'

=> "Lannister pays his debts"</pre></div>
  <p>
    dot syntax can be chained to read from nested maps (maps inside maps) too
  </p>
  <div class="code">
    <pre>~mymap.city.name~

=> "Sydney"</pre></div>
  <p>
    note that the map keys that occur after the '.' must be strings to use this syntax.
  </p>
  <p>
    for keys that are not strings, or not known until runtime, you can use the bracket syntax,
    similar to indexing into a list
  </p>
  <div class="code">
    <pre>read(map, key) ->
  ~map[key]~

read({ 'name' : 'Tyrion'}, 'name')

=> "Tyrion"</pre></div>
  <p>
    here the <code>[key]</code> part tells loop to look for an entry in the map whose value is
    equivalent to the variable, key. later, when we call <code>read()</code>, the variable
    <code>key</code> contains <code>"name"</code> and so prints <code>"Tyrion"</code>
    you can also write to maps, similarly
  </p>
  <div class="code">
    <pre>starkify(map) ->
  ~map.house: 'Stark'~

starkify({ 'name' : 'Tyrion'})

=> { name=Tyrion, house=Stark }</pre></div>
  <p>
    this is the first time we've seen the assign operator <code>':'</code> (interchangeable with
    <code>'='</code>). we'll encounter it a lot more further on but for now, read it as assigning
    the value to the right of the <code>:</code> to the slot represented by its left.
  </p>

  <p>
    like sets and lists, maps are also fully compatible with java's <code>java.util.Map</code>
    type.
  </p>

  <h3>Trees</h3>
  <p>
    like sets are to lists, loop provides a simple syntactic abstraction to represent binary trees.
    a binary tree in loop is also compatible with <code>java.util.Map</code> and is used to
    associate keys to values. its keys are, however, kept in natural sorted order which may be
    realized during iteration. we'll see more about this when looking at list comprehensions.
  </p>
  <div class="code">
    <pre>['Sansa': 'Stark',
'Catelyn': 'Stark',
'Brandon': 'Stark',
'Arya': 'Stark',
'Robb': 'Stark',
'Eddard': 'Stark'].keySet()

=> [ Arya, Brandon, Catelyn, Eddard, Robb, Sansa ]</pre></div>
  <p>
    note that the keys went in in an arbitrary order and when printed produced a sorted result
    according to alphabetical order.
  </p>

  <h3>Symbols</h3>
  <p>
    strings are extremely useful to represent data, however they are somewhat cumbersome to
    represent particular kinds--map keys for example. like ruby, loop ships with support for
    <i>interned</i> strings called symbols. they are more concise to write and perform marginally
    better at runtime
  </p>
  <div class="code">
    <pre>{ @name: 'Tyrion',
  @house: 'Lannister' }</pre></div>
  <p>
    in loop symbols are prefixed with the <code>@</code> character and unlike ruby are
    completely interchangeable with strings
  </p>
  <div class="code">
    <pre>@popsicle == 'pop' + 'sicle'

=> true</pre></div>

  <p>
    all these data types and structures we've learned about can be combined
    to model rich ontologies to suit your needs
  </p>
  <div class="code">
    <pre>{ @houses: { 'Lannister', 'Stark', 'Targaryen' },
  @protagonists: { 'Jon', 'Dany', 'Tyrion' }
  @locations: [ 'Winterfell'   : 'Stark',
                'Targaryen'    : 'Dragonstone',
                'Casterly Rock : 'Lannister' ]}</pre></div>

  <h3>String manipulation</h3>

  <p>
    like lists, loop provides a number of special syntax extensions for working with strings.
    these are just normal java strings. let's look at a few: indexing works with strings exactly
    as it does with lists
  </p>

  <div class="code">
    <pre>'hello'[2]

=> 'l'</pre></div>

  <p>
    note that the object returned is also a string (rather than a <code>java.lang.Character</code>).
    and like lists you can also slice strings
  </p>
  <div class="code">
    <pre>str: 'hello'
print(str[2..4])
print(str[2..])
print(str[..4])

=> ll
=> llo
=> hell</pre></div>

  <p>
    you can also test if a string is a subsequence of another string with the <i>index-of</i>
    syntax
  </p>
  <div class="code">
    <pre>sub?(str, smaller) ->
  str[smaller] > -1

'yellow'.sub?('ell')
'madam im adam'.sub?('mima')
'yellow'['lo']

=> true
=> false
=> 3</pre></div>

  <p>
    these tools make working with strings more declarative and readable, in line with loop's
    functional philosophy.
  </p>

  <h2>Basic expressions</h2>

  <p>
    ok now we're armed with numeric, string and structure types and know a tiny bit about how
    to call functions with arguments. let's delve a bit deeper
  </p>
  <h3>Calling functions</h3>
  <p>
    a function is one of the most basic constructs in loop. a function takes in values
    (called <i>arguments</i>) and returns a single value, always.
    there are no <i>void</i> functions in loop. at runtime, loop functions are compiled directly
    into java functions. you call a loop function by writing its name followed by an argument list
    enclosed in parentheses - <code>()</code>
  </p>
  <div class="code">
    <pre>print('hi')</pre></div>
  <p>
    not all functions have arguments, but the parentheses must always be present:
  </p>
  <div class="code">
    <pre>hi ->
  print('hi')

hi()

=> hi</pre></div>

  <p>
    loop functions can take anything as an argument: numbers, strings, objects, or even other
    functions
  </p>
  <div class="code">
    <pre>meta(func) ->
  func.@call('hi')   # calls print()

meta(print)

=> hi</pre></div>
  <p>
    note the special syntax to call a function. the variable <code>func</code> contains a reference
    to the <code>print()</code> function. to invoke it, we call the special form
    <code>@call</code>, which in turn calls <code>print</code> with its own arguments.
  </p>
  <p>
    a function can be treated like any other value in loop, it can be stored in a variable or
    passed around to other functions as we've just done.
  </p>
  <p>
    as we've seen earlier you can also call methods on java objects. this happens in exactly the
    same way as in java
  </p>
  <div class="code">
    <pre>print('hi'.toUpperCase())

=> HI</pre></div>
  <p>
    here, we're calling the java method <code>String.toUpperCase()</code>, and then passing its
    result to <code>print()</code>. you can call methods on any object in loop this way.
  </p>
  <div class="code">
    <pre>print('hi'.toUpperCase().toLowerCase())
print(22L.intValue())
print(new java.util.Date().getClass().getName())

=> hi
=> 22
=> java.util.Date</pre></div>

  <p>
    loop also provides a form for calling loop functions like you call methods. this is know as the
    <i>call-as-method</i> feature. let's define a simple loop function <code>triple()</code>, that
    takes an integer and multiplies it by 3.
  </p>
  <div class="code">
    <pre>triple(i) ->
  i * 3

triple(2)

=> 6</pre></div>

  <p>
    this is the standard way to call loop functions, but you can also write it like this:
  </p>
  <div class="code">
    <pre>triple(i) ->
  i * 3

2.triple()

=> 6</pre></div>
  <p>
    in this instance we're treating the left hand side of the function as its first argument. you
    can call any loop functions (that are in the current namespace) 'as methods' this way, including
    ones that take multiple arguments
  </p>
  <div class="code">
    <pre>multiply(x, y) ->
  x * y

5.multiply(6)

=> 30</pre></div>
  <p>
    call-as-method provides a nice scheme for 'extending' the functionality of existing
    objects. all these values we've dealt with so far are standard java strings and integers. you
    can even use this form to <i>override</i> existing java methods with your own functionality
  </p>
  <div class="code">
    <pre>toLowerCase(str) ->
  str.toUpperCase()

'hi'.toLowerCase()

=> 'HI'</pre></div>
  <p>
    of course, you'll want to be careful when doing this to avoid confusing yourself later. loop
    provides an escape hatch in case you want to bypass any overrides and ensure that the
    underlying java method is being called.
  </p>
  <div class="code">
    <pre>toLowerCase(str) ->
  str.toUpperCase()

'HI'<-toLowerCase()

=> 'hi'</pre></div>
  <p>
    the <code>'<-'</code> reverse arrow operator signifies that a java method on the object is
    called. you are encouraged to use clear conventions to keep these schemes clear. for instance,
    i like to use the underscore naming convention for loop functions to distinguish them from
    java methods.
  </p>
  <div class="code">
    <pre># loop function
'Now is the winter of our discontent'.to_lower()

# java method
'Now is the summer of our content'.toLowerCase()
</pre></div>
  <p>
    you may instead, prefer to use the <code>'<-'</code> reverse arrow to distinguish them.
  </p>
  <div class="code">
    <pre># loop function
'Now is the winter of our discontent'.toLowerCase()

# java method
'Now is the summer of our content'<-toLowerCase()
</pre></div>

  <p>
    loop doesn't mandate one or the other, and in fact i prefer using the reverse arrow only
    when i want to clarify a potential override.
  </p>

  <h3>Navigating objects</h3>
  <p>
    we've looked at calling functions, now let's look at the values that functions manipulate and
    operate on: objects. all values in loop are compatible with java objects and vice versa. often
    objects are more than just a simple scalar value, they consist of a structure of values--as we
    saw earlier in the case of maps and lists.
  </p>
  <p>
    we saw that maps could be navigated by using the <i>dot syntax</i>, in other words, we can read
    values from the deep structure of the map by specifying a path to the desired slot
  </p>
  <div class="code">
<pre>food: {
  @name: 'Pancake',
  @nutrition: { @calories: 810, @protein: 0.2 }
}

print(~food.nutrition.calories~)

=> 810</pre></div>

  <p>
    in this example, we pick out the <code>calories</code> by specifying a path down the
    <i>graph</i> structure of the map. this should be familiar to you if you've used ruby or python.
    loop provides an identical scheme for navigating all types of objects:
  </p>

  <div class="code">
<pre>now: new java.util.Date()

print(~now.time~)

=> 1335878239084</pre></div>

  <p>
    here, im reading the <code>time</code> property out of a java <code>Date</code> object using
    the same dot-syntax. this 'property', in java, is represented by the pair of methods:
    <code>getTime()</code> and <code>setTime()</code>. the java convention is to declare method
    pairs like this to expose <i>properties</i>.
    (in ruby they are called <i>attribute accessors</i>.)
  </p>
  <p>
    loop will correctly translate this to a java method call as required. let's look at a more
    realistic example
  </p>
  <div class="code">
<pre># java code
public class Person {
  private Person parent;
  private String name;

  public Person getParent() {
    return parent;
  }

  public String getName() {
    return name;
  }

  // etc..
}


# loop code that reads java object
print("Gran's name is")
print(~person.parent.parent.name~)

=> Gran's name is
=> Grantastic E. Gran</pre></div>

  <p>
    the property navigation syntax becomes extremely useful as you write complex programs that
    interact with existing java code and libraries. loop objects can also be navigated similarly,
    as we'll see in the section on <i>classes & objects</i>.
  </p>

  <h3>If/Then/Else</h3>
  <p>
    branching in loop is similar to haskell. because all expressions must produce a value, an
    <i>if-then</i> statement must also have an <i>else</i> clause. the <code>if</code> portion
    takes any boolean expression and
    evaluates the <code>then</code> clause if true, or the <code>else</code> clause if not.
  </p>
  <div class="code">
<pre>if ~3 > 4~ then 'hooray' else 'booray'

=> booray</pre></div>
  <p>
    or more generally:
  </p>
  <div class="code">
<pre>if &lt; boolean &gt; then &lt; expression &gt; else &lt; expression &gt;</pre></div>

  <p>
    the <code>&lt; boolean &gt;</code> part may consist of any expression that results in a
    <code>true</code> or <code>false</code> value. the entire
    statement must generally appear on a single line
  </p>
  <div class="code">
<pre>classify(val) ->
  if val > 1000 then print('big') else print('small')

99.classify()

=> small</pre></div>

  <p>
    but you can split it across multiple lines if the whole expression is wrapped in parentheses
  </p>
  <div class="code">
<pre>classify(val) ->
  (if val < 1000 and val > 100
   then print('middling')
   else print('unknown'))

101.classify()

=> middling</pre></div>

  <p>
    notice I snuck in an <code>and</code> keyword here. you can similarly use <code>or</code> and
    <code>not</code> operators to combine boolean expressions, arithmetically.
  </p>

  <h3>List comprehension</h3>
  <p>
    we've already seen how lists can be sliced and their indexes read. but we can do a lot more
    with them. loop provides a class of expressions known as <i>list comprehensions</i> to quickly
    transform and make sense of lists. comprehensions replace the traditional do-while
    constructs of c and java. take a look
  </p>
  <div class="code">
<pre>i * 2 for i in [1, 2, 3]

=> [2, 4, 6]</pre></div>

  <p>
    here i am saying, for every item in the given list <code>[1, 2, 3]</code>, multiply that item
    by 2. list comprehensions act on any kind of collection (all instances of
    <code>java.util.Collection</code>) and always produce lists of equal or smaller size. for
    example:
  </p>

  <div class="code">
<pre>i for i in [1..10] ~if i % 2 == 0~

=> [1, 3, 5, 7, 9]</pre></div>

  <p>
    here i am <i>filtering</i> the a list of integers from 1 to 10 by whether or not they are odd
    (i.e. <code>i % 2 == 0</code>). the resulting list contains only items that passed the filter.
    you can even combine the filter and transformation expressions
  </p>


  <div class="code">
<pre>~i * 10~ for i in [1..10] ~if i % 2 not 0~

=> [20, 40, 60, 80, 100]</pre></div>

  <p>
    expressed more generally, a list comprehension is
  </p>

  <div class="code">
<pre>< expression > for < var > in < list > [if < filter >]</pre></div>

  <p>
    the first expression is evaluated once for every item in the list that passes the filter. the
    result of that expression is added to the output list. the filter is optional.
  </p>
  <p>
    list comprehensions must also appear on a single line but can be multiline if enclosed in
    parentheses, just like if/then/else expressions.
  </p>

  <h3>Null-safety</h3>
  <p>
    loop is a null-safe language. this means that loop expressions will not throw a
    <code>NullPointerException</code> on receiving null values. there are some exceptions to this,
    but as a general rule, loop strives to acheive a practical reduction of NPEs and the use of
    <code>null</code> in code.
  </p>
  <p>
    since there is no <code>null</code> keyword, in the loop type system, we have what is known as
    a <i>bottom</i> type. if <code>Object</code> is the <i>top</i> type, meaning every type
    inherits from object, then <code>Nothing</code> is the bottom type--meaning that it inherits
    from all types. no types may inherit from <code>Nothing</code>, and there is only one global
    instance of it, which is also referred to as <code>Nothing</code> in code
  </p>

  <div class="code">
<pre>Nothing

=> Nothing</pre></div>

  <p>
    this bit of theory aside, in practical terms you can rest assured that calling a method on
    a <code>Nothing</code> will not break your code--it simply returns <code>Nothing</code> again
  </p>

  <div class="code">
<pre>Nothing.some_method().some_other_method()

=> Nothing

empty: {:}
empty.name

=> Nothing</pre></div>

  <p>
    this even holds for java code that returns <code>null</code>
  </p>

  <div class="code">
<pre>''.getClass().getResource('doesnt_exist').toString()

=> Nothing</pre></div>

  <p>
    if you need to pass <code>null</code> into java apis for some reason, you can use
    <code>Nothing</code> instead
  </p>


  <div class="code">
<pre>person.parent = Nothing
city.setName(Nothing)
j_option_pane.showMessageDialog(Nothing, 'hi there')
# ..</pre></div>

  <p>
    loop will correctly translate this when calling into java, without any performance penalty.
  </p>
  <p>
    of course, loop cannot prevent <code>NullPointerException</code>s from being thrown in java
    code, so code that already does will continue to behave as expected. loop does not try to
    catch and translate them into <code>Nothing</code>s. you will have to handle them as you do
    any other exception (more in the section on <i>control flow</i>).
  </p>
  <p>
    additionally, loop does not permit <code>Nothing</code> in computations. it is a type error to
    attempt to compute with <code>Nothing</code> and this will cause an exception at runtime.
  </p>

  <div class="code">
<pre>1 + \Nothing\

=> \#error\</pre></div>


  <h2>Functions</h2>

  <p>
    we've already been declaring and using functions throughout the examples thus far. let's
    look at them a bit more in depth.
  </p>

  <h3>Sequences</h3>

  <p>
    a function generally takes zero or more arguments and
    returns a value. so far, all the functions have contained only one expression, but sometimes
    this is not sufficient. sometimes you need to do a sequence of things in a go, this is very
    easy:
  </p>
  <div class="code">
    <pre>increment(num) ->
  print(num),
  num + 1

3.increment()

=> 3
=> 4</pre></div>

  <p>
    here, we're executing two expressions in sequence, first we print the value of the number,
    then we return the number plus 1. a sequence may contain as many expressions as you need
  </p>

  <div class="code">
    <pre>do_stuff() ->
  print('hit any key to continue...'),
  pause(),
  print('no, hit the ANY key to continue...'),
  pause(),
  print('done!')

=> hit any key to continue...
=> no, hit the ANY key to continue...
=> done!</pre></div>

  <p>
    note that the last expression must not end in a comma. haskell programmers may be familiar
    with this as a <i>do block</i>, and for schemers, this is the equivalent of a <code>begin</code>
    sequence. however, unlike haskell, in loop a sequence is guaranteed to execute in order.
  </p>

  <h3>Local scope</h3>

  <p>
    it is often useful to define a set of values and functions specifically for a purpose. loop
    provides a lightweight and simple system to accomplish this (this should be familar for
    haskell programmers)
  </p>

  <div class="code">
    <pre>minutes_in(num) ->
  num * year
  where
    hour: 60
    day : 24 * hour
    week: 7 * day
    year: 52 * week

print("there are @{minutes_in(2)} minutes in 2 years")

=> there are 1048320 minutes in 2 years</pre></div>

  <p>
    the <i>local</i> variables <code>hour, day, week, year</code> are only available inside the
    scope of the <code>minutes_in()</code> function.
  </p>

  <div class="code">
    <pre>minutes_in(num) ->
  num * year
  where
    hour: 60
    day : 24 * hour
    week: 7 * day
    year: 52 * week

print(\year\)

=> \#error\</pre></div>

  <p>
    you can even declare functions in local scope this way
  </p>
  <div class="code">
    <pre>initials(name) ->
  first(words[0]) + first(words[1])
  where
    words: split(name)
    ~first(word) ->~
      if word.isEmpty() then '' else word[0]

initials('Theon Greyjoy')

=> 'TG'

\first\('Elric')

=> \#error\</pre></div>

  <p>
    here the function <code>first()</code> is scoped locally to the parent function
    <code>initials()</code>. it's useful to save duplicating code within the parent function,
    but not needed elsewhere so it goes out of scope
  </p>
  <p>
    locally scoped functions can also have local scopes of their own. there is no limit to the
    nesting depth. so please use it wisely
  </p>

  <div class="code">
    <pre>minutes_in(num) ->
  yearify(num)
  where
    yearify(num) ->
      weekify(num)
      where
        weekify(num) ->
          dayify(num)
          where
            ...
    </pre></div>

  <h3>Module scope</h3>
  <p>
    by default all top-level functions in loop are public. that means any function that is
    not part of a <i>where</i> block of another function is visible to (and callable from)
    all other parts of the program. now, local-scope is useful for helper functions that are
    private to a single function, but what if you want to share helpers <i>between</i> top-level
    functions?
  </p>
  <p>
    loop provides a third scope known as <i>module scope</i> for exactly this purpose. functions
    scoped to the module level are visible to all other parts of the same module, but nowhere
    else. in this way you can reuse important blocks of code easily, and still hide unnecessary
    implementation details by sectioning them off from other parts of your app.
  </p>
  <div class="code">
    <pre>@last(ls) ->
  ls[ls.length() - 1]

func1 ->
  [1, 2, 3].@last()

func2 ->
  [30, 20, 10].@last()

=> 3
=> 10

# a different module
func3 ->
  [10, 20].\@last()\

=> \#error\ </pre></div>

  <p>
    you declare a function as module-scoped by simply prefixing its name with <code>@</code>.
    loop will ensure that this function is restricted to the current module. note that this is
    not merely a naming convention: <code>@</code>-prefixed functions have their visibility
    enforced by the runtime.
  </p>

  <h3>Closures</h3>

  <p>
    closures, or anonymous functions, are quite useful in a language like loop where functions
    are a first-class construct. because they can be held in variables and passed around, it is
    sometimes useful to create small blocks of functionality that aren't necessarily declared
    as top-level or scoped functions. these are called closures
  </p>

  <div class="code">
    <pre>manipulate(ls, func) ->
  func.@call(i) for i in ls

manipulate([1, 2, 3], @(x) ->
                        x * 5)

=> [5, 10, 15]</pre></div>

  <p>
    in this example, i am passing a code block in the form of an anonymous function
    (<code>@</code>-sign followed by an argument list and <code>-></code> arrow) to the
    meta-function <code>manipulate()</code>, which, takes a list of items and calls the given
    function for each item in the list.
  </p>

  <p>
    the nice thing about closures is that they can refer to values in scope at the time of their
    creation long after the scope is lost
  </p>

  <div class="code">
    <pre>make(num) ->
  @() ->
    print(num)

make(10).@call()

=> 10</pre></div>

  <h2>Pattern matching</h2>

  <p>
    so far we've looked at simple functions and sequences--functions that essentially contain a
    single expression to manipulate and respond to input values. this is well and good for a lot
    of use cases, but loop provides a more powerful, declarative construct called pattern matching.
  </p>

  <p>
    pattern matching in loop is inspired by the same idea in haskell and closely mirrors the
    latter's concepts. when used properly, pattern matching can be extremely powerful, giving you
    concise, elegant programs that read like a solution rather than a process to follow.
  </p>

  <p>
    pattern matching functions in loop are denoted by a <code>=></code> arrow and embody one or
    more <i>pattern rules</i> that follow
  </p>
  <div class="code">
    <pre>speak(num) =>
  1   : 'one'
  2   : 'two'

speak(2)

=> 2</pre></div>

  <p>
    this is a naively simple pattern matching function that tests if the value passed in is either
    1 or 2 and returns the appropriate string. note that it reads like a table of mappings between
    inputs and outputs. this is much nicer to work with than the equivalent standard form
  </p>

  <div class="code">
    <pre>speak(num) ->
  if num == 1 then 'one' else (if num == 2
                               then 'two' else ...)

speak(2)

=> 2</pre></div>

  <p>
    much less readable. now let's go back to the pattern matching form
  </p>

  <div class="code">
    <pre>speak(num) =>
  1   : 'one'
  2   : 'two'

speak(\ 3\ )

=> \#error: Non-exhaustive pattern rules\</pre></div>

  <p>
    notice that we don't have a rule for values other than 1 or 2. what happens if we call
    the pattern matching version of <code>speak()</code> with 3?

    since there is no behavior specified, loop complains that the rules are insufficient.
    in the simple if/then case we can handle this with an additional <code>else</code>,
    however in pattern matching we need to use a <i>wildcard</i> rule
  </p>

  <div class="code">
    <pre>speak(num) =>
  1   : 'one'
  2   : 'two'
  ~*   : 'other'~

speak(3)

=> other</pre></div>

  <p>
    the asterisk - <code>*</code> denotes any value, and is matched last, if all the other rules
    fail.
  </p>
  <p>
    of course this will match <i>anything</i> not just other numbers
  </p>

  <div class="code">
    <pre>speak(num) =>
  1   : 'one'
  2   : 'two'
  *   : 'other'

speak(~'dont say a word!'~)

=> other</pre></div>

  <p>
    if you want the rules to be stricter (so the function only accepts integers), you can impose
    a <i>type pattern rule</i> instead
  </p>


  <div class="code">
    <pre>speak(num) =>
  1       : 'one'
  2       : 'two'
  ~Integer : 'other'~

speak(3)

=> other

speak(\'say no more'\)

=> \#error: Non-exhaustive pattern rules\</pre></div>

  <p>
    note that the order in which the rules appear is important.
  </p>

  <h3>Polymorphism</h3>

  <p>
    as you may have guessed, loop's alternative to <i>function overloading</i> is the use of
    mixed pattern rules. a single function can be made to perform different actions
    depending on the input type, using pattern matching
  </p>


  <div class="code">
    <pre>times(val, num) =>
  Integer, *   : val * num
  String, *    : val for val in [1..num]

1.times(4)

=> 4

'hi'.times(2)

=> [hi, hi]</pre></div>

  <p>
    here we've introduced two new concepts:
  </p>
  <div>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet">polymorphism</li>
      <li><img src="../images/arrow_right.png" alt="bullet">multiple arguments</li>
    </ul>
  </div>

  <p>
    polymorphism in this instance is simply allowing you to call the same function with an integer
    and string respectively. with multiple arguments, the second argument is a wildcard
    rule and is separated by a comma after the first rule. all argument rules must appear on the
    same line.
  </p>
  <p>
    a pattern matching function <i>must have</i> a rule for each of its arguments. if you dont
    care what an argument is, use the wildcard rule as we've just done. otherwise remember that
    all the rules you declare are tested in the order the appear.
  </p>

  <p>
    you can of course, freely mix type rules with other kinds of rules to easily match a variety
    of different inputs.
  </p>

  <h3>List patterns</h3>

  <p>
    the simplest form of list pattern matching is literally matching the empty list:
  </p>


  <div class="code">
    <pre>empty?(ls) =>
  []      : true
  *       : false

empty?([])

=> true</pre></div>

  <p>
    in this instance the empty list matcher matches ahead of the wildcard. you can also match
    a single element list:
  </p>

  <div class="code">
    <pre>only_item(ls) =>
  ~[x]~   : x

[88].only_item()

=> 88</pre></div>

  <p>
    the neat thing here is that not only do you match the pattern rule but it also lets you
    extract items from the list conveniently. the variable <code>x</code> holds the only list
    element, and can be used in the right-hand side conveniently,
    as though it were an argument itself. this is known as list <i>destructuring</i>.
  </p>

  <p>
    list patterns are among the most useful of pattern matching capabilities in loop. the basic
    idea is to <i>destructure</i> a list into individual parts and process the items declaratively.
    as we'll see, this makes list processing code really easy to write
  </p>


  <div class="code">
    <pre>reverse(ls) =>
  []         : []
  [x:rest]   : reverse(rest) + [x]

reverse([1, 2, 3, 4, 5])

=> [5, 4, 3, 2, 1]</pre></div>

  <p>
    this function as its name implies, reverses any list passed in. the way you read this
    is as follows.
  </p>

  <p>
    the reverse of the empty list is the empty list:
  </p>

  <div class="code">
    <pre>reverse(num) =>
  ~[]         : []~
  [x:rest]   : reverse(rest) + [x]</pre></div>

  <p>
    the reverse of any list that has <i>at least one</i> item is the first item (<code>x</code>)
    appended to the
    reverse of the <i>remaining</i> items (<code>rest</code>).
  </p>

  <div class="code">
    <pre>reverse(num) =>
  []         : []
  ~[x:rest]   : reverse(rest) + [x]~</pre></div>

  <p>
    this is what's known as a <i>recursive function</i>, meaning that it calls itself (recurses)
    in order to complete its task. let's look at how this function destructures a simple list like
    <code>[1, 2, 3]</code>
  </p>

  <div class="code">
    <pre>reverse([1, 2, 3]):  1:[2, 3]  : reverse(~[2, 3]~) + [1]
reverse([2, 3]):     2:[3]     : reverse(~[3]~) + [2]
reverse([3]):        3:[]      : reverse(~[]~) + [3]
reverse([]):         []        : ~[]~

=> [3, 2, 1]</pre></div>

  <p>
    each line above represents a call of the function. on the left are the arguments it is called
    with, and on the right the pattern rule that matched and its values, after destructuring.
    what happens is that each additional recursive call gets a step closer to the empty list and
    when you unravel this stack of calls, you get the list in reverse order.
  </p>
  <p>
    read the rightmost part of the expression (in bold) from the bottom up to
    illustrate this point
  </p>

  <div class="code">
    <pre>reverse([1, 2, 3]):  1:[2, 3]  : reverse([2, 3]) ~+ [1]~
reverse([2, 3]):     2:[3]     : reverse([3]) ~+ [2]~
reverse([3]):        3:[]      : reverse([]) ~+ [3]~
reverse([]):         []        : ~[]~

# reading upwards:
~[] + [3] + [2] + [1]~ => [3, 2, 1]</pre></div>

  <h3>Object patterns</h3>

  <p>
    any object (including maps) can also be pattern matched, like lists. the primary use is to
    destructure object graphs and enable more declarative code that is easier to write and read.
  </p>


  <div class="code">
    <pre>gran(person) =>
  ~{ g <- person.parent.parent }~   : g.name</pre></div>

  <p>
    this will print the person's grandparent's name if you have an object graph that looks
    something like this:
  </p>


  <div class="code">
    <pre>billy: { @name: 'Billy',
         @parent: { @name: 'Willy',
                    @parent: { @name: 'Silly' }
                  }
}

gran(billy)

=> Silly</pre></div>

  <p>
    let's look at this code in a bit more detail:
  </p>


  <div class="code">
    <pre>gran(person) =>
  ~{ g <- person.parent.parent }~   : g.name</pre></div>

  <p>
    first we have a new type of pattern rule, encased in braces - <code>{}</code>. this signals
    to loop that the function should expect an object to destructure. next there is a variable,
    <code>g</code>, followed by a <i>reverse</i> arrow <code><-</code>, which indicates that
    <code>g</code> should <i>receive</i> the result of the destructuring.
  </p>

  <div class="code">
    <pre>gran(person) =>
  { ~g <-~ person.parent.parent }   : g.name</pre></div>

  <p>
    on the right side of the reverse arrow is the path expression in dot syntax. recall path
    expressions from the section on <i>object navigation</i>. in this instance we are asking for
    the <code>parent</code> of the <code>parent</code> of argument <code>person</code>.
  </p>

  <div class="code">
    <pre>gran(person) =>
  { g <- ~person.parent.parent~ }   : g.name</pre></div>

  <p>
    finally on the right hand side of the rule itself, is another path expression
    <code>g.name</code>, which, is the result we want to return if this pattern rule matches.
  </p>


  <div class="code">
    <pre>gran(person) =>
  { g <- person.parent.parent }   : ~g.name~</pre></div>

  <p>
    this is a rather simple example, and it can be rewritten as a standard function as follows:
  </p>


  <div class="code">
    <pre>gran(person) ->
  person.parent.parent.name</pre></div>

  <p>
    but for more complex object patterns, or for polymorphism, the pattern matching form is quite
    useful. you can add as many destructurings as required in a single object pattern rule:
  </p>


  <div class="code">
    <pre>gran(person) =>
  { g <- person.parent.parent,
    ~n <- person.name~ }    : "@{n}'s gran is @{g.name}"

=> Billy's gran is Silly</pre></div>

  <p>
    and also, mix object pattern rules with other kinds of patterns.
  </p>

  <h3>String patterns</h3>

  <p>
    string pattern matching is one are where loop shines. there are a variety of useful tools
    for matching patterns in text. these can be combined to make quite powerful parsers and
    text processors, that are readable and concise.
  </p>

  <p>
    firstly, as you might guess, any string literal can be matched as a simple rule:
  </p>


  <div class="code">
    <pre>numberize(str) =>
  'one'     : 1
  'two'     : 2
  'three'   : 3

numberize('two')

=> 2</pre></div>

  <p>this scheme will also match symbols</p>

  <div class="code">
    <pre>numberize(str) =>
  'one'     : 1
  'two'     : 2
  'three'   : 3

numberize(@two)

=> 2</pre></div>

  <p>
    of course, for clarity you should use symbols directly in your pattern rule where appropriate:
  </p>

  <div class="code">
    <pre>numberize(str) =>
  @one     : 1
  @two     : 2
  @three   : 3

numberize(@two)

=> 2</pre></div>

  <p>
    but this is just the tip of the iceberg. strings can also be destructured in a manner very
    similar to lists:
  </p>

  <div class="code">
    <pre>initial(name) =>
  (~i:rest~)     : i

initial('Megatron')

=> M</pre></div>

  <p>
    here the destructuring works by pulling apart the leading character of the string. note that
    we use parentheses - <code>()</code> instead of brackets - <code>[]</code> in the pattern rule.
    this is necessary to inform loop that we are matching a string and not a list.
  </p>

  <p>
    but strings can be destructured in even cooler ways. by specifying a delimiter, you can tell
    loop to split a string around a particular character sequence:
  </p>

  <div class="code">
    <pre>flip(name) =>
  (~first~ : ' ' : ~last~)  : "@{last}, @{first}"

flip('Optimus Prime')

=> Prime, Optimus</pre></div>

  <p>
    note that in this example, we use a single space to pattern match around. all the characters
    before it are destructured into <code>first</code> and those after it into <code>last</code>.
  </p>

  <p>
    there is no limit to how many delimiters you can add to create a pattern:
  </p>

  <div class="code">
    <pre>select(str) =>
  ('A':a:'B':b:'C':c:'D':d)   : a + b + c + d

select('A1B2C3D4')

=> 1234</pre></div>

  <p>
    and there is no restriction on the length of the delimiters
  </p>

  <div class="code">
    <pre>extract(str) =>
  ('Now is the ': ~season~ :' ':ignore)  : season

extract('Now is the winter of our discontent')

=> ~winter~

extract('Now is the summer of your content')

=> ~summer~</pre></div>

  <p>
    you can use this technique recursively to process several lines, from a text file for example:
  </p>

  <div class="code">
    <pre>uncomma(str) =>
  ''                     : ''
  (word: ',' : ~rest~)   : word + '\n' + ~uncomma(rest)~

uncomma(read('bots.csv'))

# given a file, 'bots.csv' containing:
Perceptor,Astrotrain,Starscream,Soundwave

=> Perceptor
=> Astrotrain
=> Starscream
=> Soundwave</pre></div>

  <p>
    notice the base case for the empty string, which is needed to terminate the recursion when
    the end of the file text is reached.
  </p>

  <p>
    on top of this, loop also provides powerful regex pattern matching:
  </p>

  <div class="code">
    <pre>judge(str) =>
  /(t|w)alk(ing)?/   : print('Good')
  *                  : print('Lazy!')

judge('talk')
judge('walking')
judge('idle')

=> Good
=> Good
=> Lazy!</pre></div>

  <p>
    in this instance, the regular expression (signified by bounding slashes - <code>//</code>) is
    used to match whether or not the first rule should apply. it is slightly simpler than the
    earlier examples in that it does not destructure the string in any way, instead is used to
    accept a more flexible range of inputs.
  </p>

  <p>
    but! if you <i>really</i> want to destructure using a regex pattern, that is also
    supported using a regex standard known as <i>named capturing groups</i>. a named capturing
    group is any capturing group
    occurring inside a regular expression (enclosed in parentheses - <code>()</code>) that also is
    tagged with a name. this is done using a special syntax.
    the name is then extracted and made available as a variable:
  </p>

  <div class="code">
    <pre>
extract(activity) =>
  /(?&lt; ~verb~ &gt;(t|w)alk)(ing)?/   : verb

extract('walking')
extract('talk')
extract('talking')

=> walk
=> talk
=> talk</pre></div>

  <p>
    see <a href="http://www.regular-expressions.info/named.html">this website</a> for more
    information on named capturing groups and how to write them.
    but do use them sparingly, excessive use of named groups can make regexes
    (which are, let's face it, already quite messy) totally illegible.
  </p>

  <h3>Guards</h3>

  <p>
    guards are an addendum to pattern matching and can be seen as an extra line of defense
    for declarative code before resorting to if/then/elses function bodies. whereas pattern
    rules focus on the type and structure of the data, guards
    are meant to be able to test specific conditions using arbitrary logic. let's take a look:
  </p>

  <div class="code">
    <pre>
gender(name) =>
  String     | name.startsWith('Mr.')    : @male
             | name.startsWith('Mrs.')   : @female
             | name.startsWith('Ms.')    : @female
             | else                      : @unknown
  *                                      : @error


gender('Mr. Rogers')
gender('Ms. Marple')

=> male
=> female</pre></div>

  <p>
    the trick here is that a guard is just any boolean expression that allows the execution of
    the right-hand expression if true. you can place arbitrary logic in a guard expression, as
    long as it evaluates to <code>true</code> or <code>false</code>:
  </p>

  <div class="code">
    <pre>gender(name) =>
  String     | name.startsWith('Mr.')    : @male
             | name.startsWith('Mrs.')   : @female
             | ~name.startsWith('Ms.')    :~ @female
             | else                      : @unknown
  ...</pre></div>

  <p>
    in our case we're testing the salutation of a name against a number of literal values (Mr, Mrs
    and Ms). but notice that we have an extra clause at the end, an <code>else</code> clause. this
    is necessary if the pattern matches but none of the other guard expressions do. all guarded
    patterns <i>must</i> have an <code>else</code> expression (if you recall what we said about
    if/then/else expressions, this will make sense).
  </p>

  <p>
    furthermore, it is important to distinguish between the <code>else</code> expression, which is
    effectively the default case against a <i>matched</i> pattern and the wilcard
    pattern--which is a catchall if no <i>patterns</i> matched.
  </p>

  <p>
    in the example case we can trigger the else clause by specifying any string that is missing
    a salutation:
  </p>

  <div class="code">
    <pre>gender('Pat')

=> unknown</pre></div>

  <p>
    this is different from the wilcard rule, which matches anything that failed the previous
    patterns (and is effectively polymorphic):
  </p>

  <div class="code">
    <pre>gender(22)

=> error</pre></div>

  <p>
    in a sense, you can think of guards as analogous to a <code>switch</code> statement in c or
    java, except that they can handle any kind of expression, and do so in linear order. a better
    analogue might be an if-elseif-elseif-elseif-... style block, with a final else. except that
    guards are far easier to read and far simpler to write.
  </p>

  <p>
    here is a guarded function that determines if an integer falls into predefined ranges:
  </p>

  <div class="code">
    <pre>range(x) =>
  *           | x > 100     : @large
              | x < 0       : @negative
              | x < 100     : @small
              | else        : @exactly100

range(224)
range(4)
range(-6)

=> large
=> small
=> negative</pre></div>

  <p>
    notice how the order of evaluation played a part in our function, which correctly classifies
    values between 0 and 100 as small, even though the <code>@small</code> rule is only written to check for
    <code>x < 100</code>. using guards this way makes complex branching easy to visualize and
    reason about.
  </p>

  <p>
    sometimes people are confused between when you need to use a guard and when you use just another
    pattern rule. there are no strict guidelines about this, but one way to think of it that
    patterns are about the structure of objects, and guards about their <i>value</i>, or data.
  </p>

  <p>
    this distinction becomes clear when you consider that pattern rules do not cause any functions
    to be called, whereas guards often do. meaning that pattern rules describe the static behavior
    of the program (what types are accepted, what structure of objects or pattern of strings), and
    guards describe the dynamic behavior of the program, i.e. what result is produced if a
    condition is satisfied.
  </p>

  <p>
    guards are useful in a variety of situations, and they may be applied on any kind
    of pattern rule. look at some loop examples to get a feel for how guards can be used.
  </p>

  <h2>Control flow</h2>

  <p>
    since loop is a jvm language, it honors the java system of exceptions for handling control
    flow in error cases. loop exceptions are just java exceptions except that it does not support
    the concept of <i>checked exceptions</i>. all exceptions in loop are <i>unchecked</i>,
    usually a kind of <code>RuntimeException</code>.
  </p>

  <h3>Raising exceptions</h3>

  <p>
    exceptions in loop are <i>thrown</i> using the <code>raise()</code> function which is always
    available in all programs:
  </p>

  <div class="code">
    <pre>divide_by(x, y) ->
  if y != 0 then x / y else ~raise~('divide by zero')

main ->
  1.divide_by(0)

=> \#error: divide by zero\</pre></div>

  <p>
    this simplistic function checks if the divisor is equal to <code>0</code> and raises an
    exception if so. the function <code>raise()</code> terminates execution immediately and
    unravels the function stack until it is <i>handled</i> or the program exits in error.
  </p>

  <p>
    the familiar jvm <i>stack trace</i>, showing each function call in the chain of execution that
    led to this exception, is generated properly by all loop programs. here's an example:
  </p>
  <div class="code">
    <pre>java.lang.RuntimeException: ~divide by zero~
    at prelude.raise(prelude.loop:9)
    at _default.divide_by(test.loop:3)
    at _default.main(test.loop:6)</pre></div>

  <p>
    by default, <code>raise()</code> throws a <code>java.lang.RuntimeException</code> with an
    embedded cause message.
    (this example presupposes that the <code>divide_by()</code> function is saved in a file called
    <code>test.loop</code>, which is called from the command line using the loop runtime.)
  </p>

  <p>
    otherwise, it is nice to see that the trace points correctly to the offending line of code,
    line #3 in <code>test.loop</code>:
  </p>
  <div class="code">
    <pre>java.lang.RuntimeException: divide by zero
    at prelude.raise(prelude.loop:9)
    ~at _default.divide_by(test.loop:3)~
    at _default.main(test.loop:6)</pre></div>
  <p>
    you may also note that the stack trace is
    clean, and only presents loop functions with none of the intermediate java gunk that other
    jvm languages often leave behind.
  </p>

  <p>
    of course, if your loop code calls third-party java methods you may see it after all ;)
  </p>

  <h3>Handling exceptions</h3>

  <p>
    exceptions in loop are handled via a specialization of pattern matching functions called
    <i>handler</i> forms. these are pretty much just a normal pattern matching function, but with
    some additional constraints imposed. let's try to handle the divide-by-zero error from the
    previous example:
  </p>

  <div class="code">
    <pre>divide_by(x, y) ~except handler~ ->
  if y != 0 then x / y else raise('divide by zero')

~handler~(e) =>
  *      : e.message

1.divide_by(0)

=> divide by zero</pre></div>

  <p>
    there are a couple of changes we've made here. firstly, there is a new function simply called
    <code>handler()</code> (you can call it whatever you want). secondly, we have added a clause
    to the <code>divide_by()</code> function which reads <code>except handler</code>. this is the
    exception handler clause which tells loop to catch exceptions thrown by the declaring function
    and hand them off to the specified function for processing.
  </p>

  <p>
    furthermore, we see that this time there is no error, instead we simply get back the message
    <code>divide by zero</code>, which was extracted from the exception object itself:
  </p>


  <div class="code">
    <pre>divide_by(x, y) except handler ->
  if y != 0 then x / y else raise('divide by zero')

handler(e) =>
  *      : ~e.message~

1.divide_by(0)

=> ~divide by zero~</pre></div>

  <p>
    Since the exception is passed as an argument to <code>handler()</code>, we can use pattern
    matching to provide the appropriate recovery response.
  </p>
  <p>
    This lets you handle any exception thrown using <code>raise()</code>. You can even use guards
    here to do interesting things:
  </p>
  <div class="code">
    <pre>divide_by(x, y) except handler ->
  if y != 0 then x / y else raise(~'dbz'~)

handler(e) =>
  { msg <- e.message }  | ~msg == 'dbz'~  : 0
                        | else          : raise(e)

1.divide_by(0)

=> 0</pre></div>

  <p>
    Here we're using a combination of <i>object pattern matching</i> (see earlier section) and
    guards to check if the exception contains a particular message. If it does, we return zero
    as if nothing abnormal happened. Otherwise, the exception is rethrown.
  </p>

  <h3>Handling java exceptions</h3>

  <p>
    Of course, loop's simple exceptions aren't the only kind you'll have to deal with. Java
    exceptions come in a variety of types that don't all extend from <code>RuntimeException</code>.
    To handle these properly, we can use a <i>type pattern</i> rule:
  </p>

  <div class="code">
    <pre>io_handler(e) =>
  IOException      : e.message
  *                : raise(e)</pre></div>

  <p>
    In this example, we're catching any instance of <code>IOException</code> and returning the
    message. For all other kinds, we rethrow the exception. The wildcard rule will catch any
    subtype of <code>java.lang.Exception</code> including all <code>RuntimeException</code>s.
  </p>

  <p>
    Loop will correctly generate the Java bytecode to catch only the exceptions specified by
    type pattern rules, <i>in the order</i> they are specified. So if you want to you can even
    write:
  </p>

  <div class="code">
    <pre>io_handler(e) =>
  FileNotFoundException   : raise(e)
  IOException             : e.message</pre></div>

  <p>
    This handler will rethrow the exception if a file is not found, otherwise it simply returns
    the error message, catching the exception. However, note that since we have only specified
    two exception types, anything that's thrown of a <i>different</i> type, say
    <code>NumberFormatException</code>, won't be caught or handled.
  </p>
  <p>
    Loop is smart enough to catch only the specific exception types--note that there is no
    catch/analyze/rethrow penalty, as the correct bytecode is generated underneath.
  </p>

  <p>
    Please also remember that the wildcard rule will only catch <code>Exceptions</code>, not
    <code>java.lang.Error</code>s or other types of <code>java.lang.Throwable</code>. If you wish
    to catch these types, you must specify them explicitly:
  </p>
  <div class="code">
    <pre>io_handler(e) =>
  FileNotFoundException   : raise(e)
  ~OutOfMemoryError        : exit(1)~
  *                       : e.message</pre></div>

  <h2>Classes and objects</h2>

  <p>
    In addition to working with Java classes and objects, Loop also provides its own, more ideal
    type system. Classes in Loop are simple graphs of data that have no private state and
    no methods. Formally, they define a grouping of properties identified with a common purpose
    or model. All properties are publicly accessible by all functions.
    You can think of Loop classes like <i>structs</i> in C or C#, or as a formalization of
    the map data structure we encountered earlier.
  </p>

  <h3>Constructors</h3>

  <p>
    Loop objects are simply instances of these classes. They are created using the <code>new</code>
    keyword and all have implicit constructors.
  </p>

  <div class="code">
    <pre>class Star ->
  name
  mass

new Star()</pre></div>

  <p>
    This will create an empty object, which, is no different from the empty map:
  </p>

  <div class="code">
    <pre>new Star() == {:}

=> true</pre></div>

  <p>
    Like maps and Java objects, reading the properties of a Loop object is done via <i>dot-syntax</i>:
  </p>

  <div class="code">
    <pre>star: new Star()
~star.name~

=> Nothing</pre></div>

  <p>
    Every Loop type automatically has a dynamic set of constructors for providing its initial set
    of properties:
  </p>

  <div class="code">
    <pre>class Star ->
  name
  mass

new Star(name: 'Proxima Centauri',
         mass: 0.123)</pre></div>

  <p>
    Note that these are constructors that take <i>named arguments</i>. Each argument is tagged
    with the name of the property for which you are specifying the value. This makes it clear
    what you're passing in when you have large constructors.
  </p>

  <p>
    Of course, if you don't know a value at construction time, you can simply leave it out:
  </p>

  <div class="code">
    <pre>class Star ->
  name
  mass

new Star(name: 'Proxima Centauri')</pre></div>

  <p>
    This object will return nothing when you query its <code>mass</code> property, but its
    <code>name</code> has been set.
  </p>

  <div class="code">
    <pre>class Star ->
  name
  mass

star: new Star(name: 'Proxima Centauri')
star.name
~star.mass~

=> Proxima Centauri
=> Nothing</pre></div>

  <p>
    Setting (or re-setting) a property is done with the assign operator:
  </p>

  <div class="code">
    <pre>class Star ->
  name
  ~mass~

star: new Star(name: 'Proxima Centauri')
~star.name: 'Errai'~
star.name

=> Errai</pre></div>

  <h3>Defaults</h3>

  <p>
    Loop has no explicit constructor function, instead if you want to specify certain default
    values that are preset on all instances of a class, you can directly specify it in the class
    definition:
  </p>

  <div class="code">
    <pre>class Star ->
  name
  ~mass: 0.123~

star: new Star(name: 'Proxima Centauri')
star.mass

=> 0.123</pre></div>

  <p>
    Any expressions specified in the class definition will be evaluated along with the constructor
    and stored in the appropriate property when the object is instantiated. You are free to invoke
    methods or specify any other kind of expression here. The only restriction is that you may not
    refer to other properties of the same object.
  </p>

  <div class="code">
    <pre>class Star ->
  name
  default_mass: 0.123
  \mass: default_mass\

=> \#error\</pre></div>

  <p>
    If you want to share a value like this, you must specify it explicitly in a constructor.
  </p>

  <p>
    While Loop objects resemble freeform maps, there are some important restrictions:
  </p>

  <div>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet"> properties cannot be <i>deleted</i></li>
      <li><img src="../images/arrow_right.png" alt="bullet"> you cannot set functions in properties</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> you cannot set closures in properties</li>
    </ul>
  </div>

  <h3>Immutability</h3>

  <p>
    Immutability, or the idea of an object whose structural data cannot change once created, is
    a very important precept in any language that allows concurrency (multi-threaded programming).
    Loop is no exception. In fact, since Loop has a strong focus on concurrency, immutability is
    integrated into the core of the language itself.
  </p>

  <p>
    Threads in Loop are not allowed to share mutable state (except via memory transactions, which
    we'll see later). In order to allow them to share fixed data, however, Loop provides a special
    construct called <i>immutable types</i>.
  </p>

  <div class="code">
    <pre>immutable class Star ->
  name
  mass

star: new Star(name: 'Proxima Centauri',
               mass: 0.123)
star.name
\star.name: 'Errai'\

=> Proxima Centauri
=> \#error\</pre></div>

  <p>
    Note the addition of a new keyword to the class definition: <code>immutable</code>. This tells
    Loop that instances of class <code>Star</code> may not be altered after they are created. So
    any properties <i>must</i> be set via the constructor.
  </p>

  <p>
    In this case, an attempt to mutate the value <code>name</code> resulted in a
    <i>mutation error</i>. This ensures that we can share objects like this between threads, safely,
    without worrying about their data becoming corrupt or inconsistent. We'll see how this is
    done in much greater detail, in the section on <i>Concurrency</i>.
  </p>

  <h3>Duck typing</h3>

  <p>
    We've briefly seen that objects in Loop can be compared with maps in a compatible fashion. This
    is part of a much broader feature known as <i>duck typing</i>. It involves the idea that an
    object whose structure resembles that of another is equivalent to it.
  </p>
  <p>
    Let's say we have a function that prints the name and age of a Star:
  </p>

  <div class="code">
    <pre>name_age(star) ->
  print("@{star.name} is @{star.age} years old")

name_age(new Star(name: 'Proxima Centauri',
                  age: 40000000))

=> Proxima Centauri is 40000000 years old</pre></div>

  <p>
    Now, this function expects an argument called <code>star</code>, but really it expects any
    object that has two properties: <code>name</code> and <code>age</code>. So we can easily write:
  </p>

  <div class="code">
    <pre>class Person ->
  name
  age

name_age(new Person(name: 'Nikola Tesla',
                    age : 142))

=> Nikola Tesla is 142 years old</pre></div>

  <p>
    This is completely legal and works as expected because of duck typing. In other words:
  </p>

  <blockquote>
    if it walks, talks and quacks like a duck, then it is in fact, a duck.
  </blockquote>

  <h2>Java interop</h2>

  <p>
    As said earlier, Loop interoperates well with Java. So far we've seen how to call instance
    methods on Java objects seamlessly; and create new Java objects by calling their constructors.
    Now let's take
    a quick look at some other conveniences.
  </p>

  <h3>Static methods</h3>

  <p>
    Loop has a special syntax for referring to static methods of Java classes:
  </p>

  <div class="code">
    <pre>~`java.lang.System`~.currentTimeMillis()

=> 1337221827894</pre></div>

  <p>
    Note the backticks - <code>``</code> around the type reference to <code>java.lang.System</code>.
    This tells loop that we are referring to a Java type and must resolve any method calls as a
    static member of the class. The function <code>currentTimeMillis()</code> returns the current
    system clock time in number of milliseconds since the beginning of the epoch.
  </p>

  <h3>Static fields</h3>

  <p>
    Class member (or static) fields are similarly resolved on Java types, but must be specified
    using a special operator:
  </p>
  <div class="code">
    <pre>~`java.lang.System::out`~.println('hi')

=> hi</pre></div>

  <p>
    Notice the <code>::</code> operator which designates the name of the static field (in our case,
    <code>out</code>). The entire field reference must appear <i>inside</i> the backticks and the
    resolved field left to be evaluated against whatever expression you put around it. In this
    example, I'm calling the method <code>println()</code> which simply outputs a string to the
    console. In fact, this is exactly how Loop's own <code>print()</code> function works internally.
  </p>

  <h3>Type references</h3>

  <p>
    It is sometimes useful to resolve a Java class itself. Some libraries take classes as arguments,
    or you just may want to ensure that a Java class is available in the current process. As you
    might guess, you can refer to a Java type using the same backticks syntax we've seen so far:
  </p>

  <div class="code">
    <pre>print(`java.util.Date`)

=> java.util.Date</pre></div>

  <p>
    This is the equivalent of the following Java code fragment:
  </p>

  <div class="code">
    <pre>System.out.println(java.util.Date.class)</pre></div>

  <h2>Modules</h2>

  <p>
    Modules in Loop are ways of packaging and shipping utility programs for use with other Loop
    programs. Modules may also be used as a simple way of organizing a large project and are
    usually composed of cohesive groups of functions and classes.
  </p>

  <p>
    The process of making such a module available for use in your program is called <code>importing</code>.
    In Loop, you use the <code>require</code> keyword to import a module by name:
  </p>


  <div class="code">
    <pre>require file

print(read('file.txt'))</pre></div>

  <p>
    Here, the module <code>file</code> is <i>imported</i> for use by our program. It provides the
    function <code>read()</code>, and we can thus use it without declaring it specially. This
    function reads the contents of a file named <code>autobots.txt</code> and returns a string.
  </p>


  <div class="code">
    <pre>require file

print(~read('autobots.txt')~)</pre></div>

  <p>
    Go ahead and create yourself a text file (in any editor) with a list of autobots and run
    the program. For me this prints out:
  </p>


  <div class="code">
    <pre>Hot Rod
Arcee
Ironhide
Perceptor
Optimus Prime</pre></div>

  <p>
    Nice! We didn't have to call any Java code or define any additional functions. The <code>file</code>
    module did all the work for us. This module ships with loop, and is part of its <i>core library</i>.
    It provides many other functions useful for manipulating and working with files.
  </p>

  <p>
    Now, all the functions in the file module are available in your program. However, this can present
    a problem if we already have functions with the same names. Let's take <code>read</code> as an
    example:
  </p>


  <div class="code">
    <pre>require file

~read(val)~ =>
  /[0-9]+/    : val.to_integer()
  *           : val

print(read('autobots.txt'))

=> \autobots.txt\</pre></div>

  <p>
    Now we have declared a function that converts strings to integers that is also called
    <code>read()</code>. When we run the program, we dont get any errors, rather we get the
    wrong behavior. One way to fix this problem is to rename our function to something like
    <code>@read()</code>, but this is not a great solution. Both functions are legitimately called
    <code>read()</code> and there is no reason why one should have to give up the name to the
    other.
  </p>

  <p>
    Loop provides a feature known as <i>import aliasing</i> to solve this problem:
  </p>


  <div class="code">
    <pre>require file as f

read(val) =>
  /[0-9]+/    : val.to_integer()
  *           : val

print(f.read('autobots.txt'))</pre></div>

  <p>
    In this example, we have added a suffix to the require declaration, <code>as f</code>. This
    tells Loop to box all the functionality in module file into a <i>namespace</i> called
    <code>f</code> (you can call this whatever you like, even <code>file</code>). Now, when we use
    functions from the <code>file</code> module, we prefix the function call with the alias:
  </p>

  <div class="code">
    <pre>require file as ~f~

read(val) =>
  /[0-9]+/    : val.to_integer()
  *           : val

print(~f.read~('autobots.txt'))

=> Hot Rod
=> Arcee
=> Ironhide
=> Perceptor
=> Optimus Prime</pre></div>


  <p>
    Now when we run the program, Loop correctly resolves the <code>read()</code> function against
    module <code>file</code> and we get our desired list of autobots.
  </p>

  <h3>First module</h3>

  <p>
    So far, all the programs we've written have not been in any particular module. By default,
    Loop puts your program into a module called <code>_default</code> (inside the Loop shell, this
    is the <code>_shell</code> module). This is a convenience that works well for a small script,
    but isn't really practical once you have an application consisting of several interacting
    loop scripts.
  </p>

  <p>
    To name your module, place a module declaration at the very top of the script:
  </p>

  <div class="code">
    <pre>~module botreader~

require file as f

read(val) =>
  /[0-9]+/    : val.to_integer()
  *           : val

run ->
  print(f.read('autobots.txt'))</pre></div>

  <p>
    Here, we've taken the last example and added a module declaration. To make this work properly,
    you <i>must</i> save this file as <code>botreader.loop</code>. The module name must match the
    file name in most cases (there are some exceptions which we will look at later).
  </p>

  <p>
    Now we can <i>use</i> the <code>botreader</code> module from other loop programs, easily:
  </p>

  <div class="code">
    <pre>require botreader

run()

=> Hot Rod
=> Arcee
=> Ironhide
=> Perceptor
=> Optimus Prime</pre></div>

  <p>
    Note that this only works if both loop scripts are in the same directory. Modules bundled
    with loop (such as <code>file</code>) or in <i>packages</i> do not need to be in the
    same directory. We'll see what this means in the next section.
  </p>

  <h3>Packaging</h3>

  <p>
    To be documented.
  </p>

  <h3>Prelude module</h3>

  <p>
    In a lot of these examples, we've used functions like <code>print()</code> and <code>last()</code>
    quite liberally. These are not declared anywhere, nor are we explicitly importing them from
    any module with a require directive. How then are they popping up in our code?
  </p>

  <p>
    The answer is the <i>prelude</i> module. All Loop programs implicitly import a built-in module
    called <code>prelude</code>, which provides a bunch of common functionality for convenience.
    These are some of the functions that are part of prelude:
  </p>

  <h4>General functions</h4>

  <div>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>print()</b> - writes a value to the console</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>alert()</b> - shows a popup dialog with given text</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>to_integer()</b> - converts a string with numbers to an integer</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>embiggen()</b> - converts numbers to greater precision</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>exit()</b> - terminates the program execution</li>
    </ul>

    <h4>List & String functions</h4>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>last()</b> - returns the last item in a list or string</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>push()</b> - adds a value to the end of a list</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>pop()</b> - removes and returns the last item in a list</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>head()</b> - returns the first item in a list</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>tail()</b> - returns a slice of the list with all items after the head</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>reverse()</b> - returns a copy of the list with items in reverse order</li>
    </ul>
  </div>

  <p>
    You can inspect the full source code of the prelude module here:
    <a target="_blank" href="https://github.com/dhanji/loop/blob/master/resources/loop/lang/prelude.loop">https://github.com/dhanji/loop/blob/master/resources/loop/lang/prelude.loop</a>
  </p>

  <p>
    Just as we saw with the file module and our custom <code>read()</code> function, you can also
    have collisions with the prelude module. While you can't prevent the import of prelude, you
    can definitely <i>alias</i> it to prevent function name collisions.
  </p>

  <div class="code">
    <pre>require prelude as ~pre~

print(val) ->
  ~pre.print~(val.toUpperCase())

print('hi there')

=> HI THERE</pre></div>

  <h3>Hierarchical modules</h3>

  <p>
    To be documented.
  </p>

  <h2>Concurrency</h2>

  <p>
    Much of Loop's design is based around the idea that programs are increasingly running on
    multiple CPUs (or cores) and that there is a pressing need for robust and simple tools to
    create concurrent programs. Loop takes the position that these tools are best provided by
    the language itself, and that the nitty-gritty of particular low-level concurrency constructs
    (mutexes, semaphores, CAS instructions, etc.) should not intrude on everyday programming.
  </p>

  <p>
    This is not to say that you should not familiarize yourself with these concepts, and know them
    in reasonable detail, but that you should not have to work with them for most practical uses.
    One analogy might be that while an astronaut should be reasonably familiar with the physics of
    space flight, she should not have to work out the Newtonian propulsion equations to ignite each
    stage of a rocket during flight. A lever or button would suffice.
  </p>

  <p>
    There are two principal constructs in loop for working with concurrency: <i>channels and
    memory (or cell) transactions</i>. Both are well-known, and well-established tools for
    writing concurrent programs, but Loop takes them a step further and integrates them deeply
    into the language itself, and with each other.
  </p>

  <h3>Channels and message-passing</h3>

  <p>
    You may be familiar with <i>message-passing</i> as a framework for coordination between
    multiple concurrent processes. Many languages and libraries provide something like this.
    The theory is that if concurrent processes only ever communicate by sending messages to each
    other, then there is no shared mutable state, and limited potential for memory corruption,
    deadlocks and starvation.
  </p>

  <h3>Channels</h3>

  <p>
    Channels are an abstraction over message passing and thread pools that allows you to work in
    terms of events and event handling functions. A channel consists of an <i>event queue</i> and a
    <i>handler function</i>, backed by a pool of threads. Let's take a look:
  </p>

  <div class="code">
    <pre>require channels

print_message(msg) =>
  -1        : @shutdown
  *         : print(msg)


main ->
  channel(@printer, print_message, {:}),
  @printer.send(i) for i in [1..10],
  @printer.send(-1)</pre></div>

  <p>
    The first thing you'll notice is that we're importing a module called <code>channels</code>;
    this is a built-in module that ships with loop to provide all the concurrency tools you'll
    need for working with channels.
  </p>

  <p>
    Second, we have a pattern-matching function, <code>print_message()</code> that takes a single
    argument and in the general case, just prints it out. If this argument is equal to
    <code>-1</code>, however, the function returns a symbol named <code>@shutdown</code>. This is
    a special symbol that the channels API recognizes and responds by shutting down the channel.
  </p>

  <p>
    Finally we have a few lines in <code>main()</code> to establish a channel and send it some
    events to process:
  </p>

  <div class="code">
    <pre>main ->
  ~channel(@printer, print_message, {:}),~
  @printer.send(i) for i in [1..10],
  @printer.send(-1)</pre></div>

  <p>
    Calling the function <code>channel()</code> establishes a channel called <i>printer</i>, whose
    event function is <code>print_message()</code>. Any events received by this channel will be
    dispatched to this function. Lastly, the empty map - <code>{:}</code> is used to say that we
    want the default channel options (we'll see how to use some of these options later).
  </p>

  <p>
    More generally, this function has the following signature:
  </p>

  <div class="code">
    <pre>channel( < name >, < function >, < options > )</pre></div>

  <div>
    <ul class="features">
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>name</b> - a symbol naming the channel</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>function</b> - reference to a function to handle events</li>
      <li><img src="../images/arrow_right.png" alt="bullet"> <b>options</b> - a map of options for the new channel</li>
    </ul>
  </div>

  <p>
    Finally, to send events to the channel we've just created, we use the <code>send()</code>
    function. This function takes two arguments, the name of the channel and a message to send.
    This message can be any object, but it <i>must</i> be immutable. Loop will complain if you try
    to send a mutable object to a channel.
  </p>


  <div class="code">
    <pre>main ->
  channel(@printer, print_message, {:}),
  ~@printer.send(i) for i in [1..10]~,
  @printer.send(-1)</pre></div>

  <p>
    When the messages arrive, they are dispatched as individual events to the event function. This
    is done in a fair manner over a thread pool that is shared between all channels. Note that in
    this example, I'm sending a sequence of numbers from 1 to 10, individually.
  </p>

  <p>
    This produces the following output:
  </p>


  <div class="code">
    <pre>6
4
3
2
9
5
7
8
10
1</pre></div>

  <p>
    The numbers appear in a random order, which might be surprising, but in fact this is channel
    <i>fairness</i> in action. When we send the 10 numbers, they get pumped into the channel's
    event queue, and then the channel's event function goes hell for leather trying to process
    the queue. Since these events are being processed in parallel, the order of
    output is unpredictable (and random).
  </p>

  <h3>Serialized channels</h3>

  <p>
    If we take the previous example, and make one small change to the channel options:
  </p>

  <div class="code">
    <pre>require channels

print_msg(msg) =>
  -1        : @shutdown
  *         : print(msg)


main ->
  channel(@printer, print_msg, { @serialize : true }),
  @printer.send(i) for i in [1..10],
  @printer.send(-1)</pre></div>

  <p>
    Then we get the following output instead:
  </p>

  <div class="code">
    <pre>1
2
3
4
5
6
7
8
9
10</pre></div>

  <p>
    Perfectly ordered. This is because we specified that the channel is a <i>serialized</i> channel,
    meaning that events are dispatched exactly one at a time. Even if there are many threads
    available in the worker pool, a serialized channel will only use a maximum of one thread
    ensuring that all events in its queue are processed <i>serially</i>.
  </p>

  <p>
    This is an extremely useful design pattern, particularly when you are dealing with large numbers
    of users, for example. Since channels are lightweight (much lighter-weight than threads), you
    can allocate one channel per user and fire off events as they arrive. You don't have to worry
    about synchronizing code for a single user, because the serialized channel ensures that it
    happens in sequence.
  </p>

  <p>
    Channels can be shutdown and re-established as many times as you like. But it is recommended
    that you hold a channel open for the lifetime of the application. Coordinating their orderly
    shutdown and restart in the middle of a program's life can be tricky, so only do it if you
    really have no other way.
  </p>

  <h3>Channel memory</h3>

  <p>
    Serialized channels also provide the ability to keep some data around for the next event that
    arrives. This allows you to accumulate state incrementally as each event arrives and use this
    for internal processing. Since this state is mutable (i.e. you can modify it), it is only
    visible inside the channel. Here's an example of a simple counter using serialized channels
    and memory:
  </p>

  <div class="code">
    <pre>require channels

increment(msg) =>
  -1        : @shutdown
  @print    : print(mem[@count])
  *         : mem[@count] = mem[@count] + 10
  where
    mem     : ~channel_memory()~


main ->
  channel(@printer, increment, { @serialize : true }),
  @printer.send(i) for i in [1..10],
  @printer.send(@print),
  @printer.send(-1)</pre></div>

  <p>
    Notice the function <code>channel_memory()</code>, which obtains a reference to the current
    channel's memory. We save this to a local reference, <code>mem</code> for easy access.
  </p>
  <p>
    Now, we've changed the printer slightly from the previous iteration, instead of merely
    printing the message, we increment a counter (a slot in <code>mem</code> called
    <code>@count</code>) by 10 each time.
  </p>
  <p>
    Finally, before shutting down, we send a special message <code>@print</code>, which just dumps
    the value of <code>@count</code> in the channel memory to the console. Running this function
    produces:
  </p>

  <div class="code">
    <pre>100</pre></div>

  <p>
    You can store anything you like in channel memory, it acts just like a map. And the data will
    stick around until you either set it to <code>Nothing</code> or shut down the channel. But
    remember that this will not be accessible in <i>other</i> channels or even in <code>main()</code>:
  </p>

  <div class="code">
    <pre>require channels

increment(msg) =>
  -1        : @shutdown
  @print    : print(mem[@count])
  *         : mem[@count] = mem[@count] + 10
  where
    mem     : channel_memory()


main ->
  channel(@printer, increment, { @serialize : true }),
  @printer.send(i) for i in [1..10],
  print(\channel_memory()\.count)
  @printer.send(-1)

=> \#error: illegal shared memory request\</pre></div>

  <p>
    Of course, each serialized channel gets its own channel memory, so whatever data you set in
    one serialized channel won't be available in another serialized channel's memory either.
  </p>

  <h3>Concurrent channels</h3>

  <p>
    Let's go back to non-serialized (or <i>concurrent</i>) channels. These run as fast as possible
    and in parallel with one another. It is important to remember they have <i>no channel memory</i>.
    If you want to keep state around and modify it in parallel you'll have to use
    <i>cell transactions</i>, which we'll look at later.
  </p>

  <p>
    Now, all channels run on the same shared thread pool. This thread pool starts with a small
    number of threads and expands with the rate of events being sent to all channels. If a particular
    (concurrent) channel is receiving too many messages and using up the majority of threads, the
    Loop runtime will attempt to balance the workload by making busy channels yield some time.
  </p>

  <p>
    However, it is not always desirable to rely on this--the yielding only occurs between
    events, and you may wish to have a more rigid (or dedicated) balance of threads per channel.
    Loop allows any concurrent channel to have its own dedicated worker thread pool by specifying
    the <code>workers</code> configuration option:
  </p>


  <div class="code">
    <pre>require channels

print_msg(msg) =>
  -1        : @shutdown
  *         : print(msg)


main ->
  channel(@printer, print_msg, { @workers : 4 }),
  @printer.send(i) for i in [1..10],
  @printer.send(-1)</pre></div>

  <p>
    Here, I'm ensuring that channel <code>printer</code> gets its own dedicated thread pool
    consisting of 4 worker threads. All events sent to this channel will then be dispatched only
    on this thread pool. Note that you can simulate a serialized channel by specifying only 1
    worker:
  </p>


  <div class="code">
    <pre>require channels

print_msg(msg) =>
  -1        : @shutdown
  *         : print(msg)


main ->
  channel(@printer, print_msg, { ~@workers : 1~ }),
  @printer.send(i) for i in [1..10],
  @printer.send(-1)</pre></div>

  <p>
    Then the output produced is:
  </p>

  <div class="code">
    <pre>1
2
3
4
5
6
7
8
9
10</pre></div>

  <p>
    This incidentally ensures that only one event gets processed at a time, which is similar to what
    we saw with serialized channels. Of course serialized channels are much more sophisticated
    than this--they have channel memory, and consume less resources, balancing fairly on the
    global thread pool, but it is still an interesting similarity.
  </p>

  <h3>Cells and memory transactions</h3>

  <p>To be done. This feature is still a WIP and will be documented when complete.</p>

  <section id="copyright">&copy; 2012 by <a href="http://rethrick.com/about">Dhanji R. Prasanna</a>.
    Some rights reserved.</section>
</section>
</body>
</html>
